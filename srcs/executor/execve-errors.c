/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execve-errors.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kmendes <kmendes@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/10/08 16:25:55 by fvarrin           #+#    #+#             */
/*   Updated: 2022/10/09 20:21:18 by kmendes          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "libft.h"
#include <errno.h>

#include <stdlib.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdio.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

#define F_NEXISTS 0
#define F_EXISTS 1
#define F_DIRECTORY 2
#define F_EXEC 4
#define F_READ 8

/**
 *
 * Helper that print the execve error and return the given status code
 *
 * @param {char *} prefix
 * @param {char *} message
 * @param {int} code
 *
 * @return {int}
 */
static int	print_execve_error(
		char *prefix,
		char *message,
		int code
	)
{
	print_custom_error(prefix, NULL, message);
	return (code);
}

/**
 *
 * @param {char *} file
 *
 * @return {int}
 */
int	get_file_status(char *file)
{
	struct stat	file_info;
	int			file_status;

	file_status = F_NEXISTS;
	if (stat(file, &file_info) < 0)
		return (file_status);
	file_status |= F_EXISTS;
	if (S_ISDIR(file_info.st_mode))
		file_status |= F_DIRECTORY;
	if (access(file, X_OK) == 0)
		file_status |= F_EXEC;
	if (access(file, R_OK) == 0)
		file_status |= F_READ;
	return (file_status);
}

/**
 *
 * Print execve error message from errno and return the status code
 *
 * @param {t_command *} command
 * @param {int} execve_errno
 *
 * @return {int}
 */
int	execve_process_error(char *command, int execve_errno)
{
	int		exit_code;
	int		file_status;

	file_status = get_file_status(command);
	exit_code = 126;
	if (execve_errno == ENOEXEC)
		return (print_execve_error(command, strerror(execve_errno), exit_code));
	if (file_status & F_DIRECTORY)
		return (print_execve_error(command, strerror(EISDIR), exit_code));
	else if (!((file_status & F_EXEC) && !(file_status & F_DIRECTORY)))
		return (print_execve_error(command, strerror(execve_errno), exit_code));
	else if (execve_errno == E2BIG || execve_errno == ENOMEM)
		return (print_execve_error(command, strerror(execve_errno), 2));
	else if (execve_errno == ENOENT)
	{
		errno = execve_errno;
		print_custom_error(command, "cannot execute",
			"required file not found");
		return (127);
	}
	else
		return (exit_code);
}
